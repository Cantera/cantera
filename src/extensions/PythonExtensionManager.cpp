//! @file PythonExtensionManager.cpp

// This file is part of Cantera. See License.txt in the top-level directory or
// at https://cantera.org/license.txt for license and copyright information.

#include "cantera/extensions/PythonExtensionManager.h"

#include "cantera/kinetics/ReactionRateFactory.h"
#include "cantera/kinetics/ReactionRateDelegator.h"
#include "pythonExtensions.h" // generated by Cython

#include <boost/algorithm/string.hpp>

namespace ba = boost::algorithm;
using namespace std;

namespace Cantera
{

PythonExtensionManager::PythonExtensionManager()
{
    if (!Py_IsInitialized()) {
        Py_Initialize();
    }

    // PEP 489 Multi-phase initialization
    PyModuleDef* modDef = (PyModuleDef*) PyInit_pythonExtensions();
    if (!modDef->m_slots || !PyModuleDef_Init(modDef)) {
        throw CanteraError("PythonExtensionManager::PythonExtensionManager",
                            "Failed to import 'pythonExtensions' module");
    }

    // Following example creation of minimal ModuleSpec from Python's import.c
    PyObject *attrs = Py_BuildValue("{ss}", "name", "pythonExtensions");
    if (attrs == NULL) {
        throw CanteraError("PythonExtensionManager::PythonExtensionManager",
                           "Py_BuildValue failed");
    }
    PyObject *spec = _PyNamespace_New(attrs);
    Py_DECREF(attrs);
    if (spec == NULL) {
        throw CanteraError("PythonExtensionManager::PythonExtensionManager",
                            "_PyNamespace_New failed");
    }
    PyObject* pyModule = PyModule_FromDefAndSpec(modDef, spec);
    if (!pyModule) {
        CanteraError("PythonExtensionManager::PythonExtensionManager",
                     "PyModule_FromDefAndSpec failed");
    }
    if (!PyModule_ExecDef(pyModule, modDef)) {
        CanteraError("PythonExtensionManager::PythonExtensionManager",
                     "PyModule_ExecDef failed");
    }
    Py_DECREF(spec);
    Py_DECREF(pyModule);
}

void PythonExtensionManager::registerRateBuilders(const string& extensionName)
{
    char* c_rateTypes = ct_getPythonExtensibleRateTypes(extensionName);
    string rateTypes(c_rateTypes);
    free(c_rateTypes);

    // Each line in rateTypes is a (class name, rate name) pair, separated by a tab
    vector<string> lines;
    ba::split(lines, rateTypes, boost::is_any_of("\n"));
    for (auto& line : lines) {
        vector<string> tokens;
        ba::split(tokens, line, boost::is_any_of("\t"));
        if (tokens.size() != 2) {
            CanteraError("PythonExtensionManager::registerRateBuilders",
                         "Got unparsable input from ct_getPythonExtensibleRateTypes:"
                         "\n'''{}\n'''", rateTypes);
        }
        string rateName = tokens[0];

        // Create a function that constructs and links a C++ ReactionRateDelegator
        // object and a Python ExtensibleRate object of a particular type, and register
        // this as the builder for reactions of this type
        auto builder = [rateName, extensionName](const AnyMap& params, const UnitStack& units) {
            auto delegator = make_unique<ReactionRateDelegator>();
            ct_addPythonExtensibleRate(delegator.get(), extensionName, rateName);
            return delegator.release();
        };
        ReactionRateFactory::factory()->reg(tokens[1], builder);
    }
}

};

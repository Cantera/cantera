# Definitions used for Jinja template replacement.

# This file is part of Cantera. See License.txt in the top-level directory or
# at https://cantera.org/license.txt for license and copyright information.

clib-macros: |-
  {% macro render_lines(lines) %}
  ## add lines used for CLib/C++ variable crosswalk
  {% for line in lines %}
  {{ line }}
  {% endfor %}
  {% endmacro %}

clib-param: |-
  @param{{ '[' + par.direction + ']' if par.direction }} {{ par.name }}

clib-comment: |-
  {{ brief }}

  {% if wraps %}
  Wraps C++ {{ what }}: `{{ wraps }}`

  {% endif %}
  {% if uses %}
  Uses:
  {% for uu in uses %}
  - `{{ uu }}`
  {% endfor %}

  {% endif %}
  {% for par in params %}
  {{ par }}
  {% endfor %}
  {% if returns %}
  {{ '@returns' + 12*' ' + returns }}
  {% endif %}
  {% if params or returns %}
  {% endif %}

clib-definition: |-
  {{ annotations }}
  {{ declaration }};

clib-function: |-
  // function: {{ cxx_wraps }}
  try {
      {{ render_lines(before) | indent(4) }}
      {% if buffer %}
      ## need to buffer a value returned by the C++ method
      {% if buffer[0] %}
      {{ buffer[0] }} = {{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% else %}
      {{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% endif %}
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}
      ## value returned by the C++ method can be used directly
      return {{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% endif %}
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-variable-getter: |-
  // variable (getter): {{ cxx_wraps }}
  try {
      {% if handle %}
      ## access class member variable
      {% if cxx_base == base %}
      ## object can be accessed directly
      {% if buffer and buffer[0] %}
      {{ buffer[0] }} = {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }};
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}{# not buffer[0] #}
      ## no crosswalk needed
      return {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }};
      {% endif %}{# buffer[0] #}
      {% else %}{# base #}
      ## object needs a cast as method is defined for specialization
      {% if buffer and buffer[0] %}
      {{ buffer[0] }} = {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }};
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}{# not buffer[0] #}
      ## no crosswalk needed
      return {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }};
      {% endif %}{# buffer[0] #}
      {% endif %}{# base #}
      {% else %}{# not handle #}
      ## variable is defined in root namespace
      {% if buffer and buffer[0] %}
      ## CLib/C++ variable crosswalk needed
      {{ buffer[0] }} = {{ cxx_name }};
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}{# not buffer[0] #}
      ## no crosswalk needed
      return {{ cxx_name }};
      {% endif %}{# buffer[0] #}
      {% endif %}{# handle #}
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-variable-setter: |-
  // variable (setter): {{ cxx_wraps }}
  try {
      {{ render_lines(before) | indent(4) }}
      {% if handle %}
      ## access class member variable
      {% if cxx_base == base %}
      ## object can be accessed directly
      {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }} = {{ cxx_args[0] }};
      {% else %}{# not base #}
      ## object needs a cast as method is defined for specialization
      {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }} = {{ cxx_args[0] }};
      {% endif %}{# base #}
      {% else %}{# not handle #}
      ## variable is defined in root namespace
      {{ cxx_name }} = {{ cxx_args[0] }};
      {% endif %}{# handle #}
      return 0;
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-constructor: |-
  ## CLib constructor template: instantiates new object
  // constructor: {{ cxx_wraps }}
  try {
      {{ render_lines(before) | indent(4) }}
      return {{ base }}Cabinet::add({{ cxx_name }}({{ ', '.join(cxx_args) }}));
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-accessor: |-
  ## CLib accessor template: exposes existing C++ object to CLib
  // accessor: {{ cxx_wraps }}
  try {
      {{ render_lines(before) | indent(4) }}
      {% if checks %}
      ## accessor uses index checker (see: sol_adjacent)
      if ({{ c_args[1] }} < 0 || {{ c_args[1] }} >= {{ base }}Cabinet::at({{ handle }})->{{ checks[0] }}()) {
          throw IndexError("{{ c_func }}", "", {{ c_args[1] }}, {{ base }}Cabinet::at({{ handle }})->{{ checks[0] }}());
      }
      {% endif %}{# checks #}
      return {{ cxx_rbase }}Cabinet::add({{ base }}Cabinet::at({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }}));
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-destructor: |-
  ## CLib destructor template
  // destructor
  try {
      {{ base }}Cabinet::del({{ handle }});
      return 0;
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-method: |-
  ## CLib method template:
  ## covers methods as well as getters and setters for scalars
  // {{ what }}: {{ cxx_wraps }}
  try {
      {{ render_lines(before) | indent(4) }}
      {% if buffer %}
      ## need to buffer a value returned by the C++ method
      {% if buffer[0] %}
      {% if cxx_base == base %}
      ## object can be accessed directly
      {{ buffer[0] }} = {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% else %}
      ## object needs a cast as method is defined for specialization
      {{ buffer[0] }} = {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% endif %}
      {% else %}
      {% if cxx_base == base %}
      ## object can be accessed directly
      {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% else %}
      ## object needs a cast as method is defined for specialization
      {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% endif %}
      {% endif %}
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}
      ## value returned by the C++ method can be used directly
      {% if cxx_base == base %}
      ## object can be accessed directly
      return {{ base }}Cabinet::at({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% else %}
      ## object needs a cast as method is defined for specialization
      return {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }})->{{ cxx_name }}({{ ', '.join(cxx_args) }});
      {% endif %}
      {% endif %}
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-array-getter: |-
  ## CLib array getter template
  // getter: {{ cxx_wraps }}
  try {
      {% if cxx_base == base %}
      ## object can be accessed directly
      auto& obj = {{ base }}Cabinet::at({{ handle }});
      {% else %}
      ## object needs a cast as method is defined for specialization
      auto obj = {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }});
      {% endif %}
      {% if checks %}
      if ({{ c_args[1] }} < obj->{{ checks[0] }}()) {
          throw ArraySizeError("{{ c_func }}", {{ c_args[1] }}, obj->{{ checks[0] }}());
      }
      {% else %}
      // no size checking specified
      {% endif %}
      {% if buffer and buffer[0] %}
      {{ buffer[0] }} = obj->{{ cxx_name }}({{ cxx_args[0] }});
      {{ render_lines(after) | indent(4) }}
      return {{ buffer[1] }};
      {% else %}
      obj->{{ cxx_name }}({{ cxx_args[0] }});
      return 0;
      {% endif %}
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-array-setter: |-
  ## CLib array setter template
  // setter: {{ cxx_wraps }}
  try {
      {% if cxx_base == base %}
      auto& obj = {{ base }}Cabinet::at({{ handle }});
      {% else %}
      auto obj = {{ base }}Cabinet::as<{{ cxx_base }}>({{ handle }});
      {% endif %}
      {% if checks %}
      if ({{ c_args[1] }} != obj->{{ checks[0] }}()) {
          throw ArraySizeError("{{ c_func }}", {{ c_args[1] }}, obj->{{ checks[0] }}());
      }
      {% else %}
      // no size checking specified
      {% endif %}
      obj->{{ cxx_name }}({{ cxx_args[0] }});
      return 0;
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-custom-code: |-
  // {{ what }}: custom code
  try {
      // *************** begin custom code ***************
      {{ render_lines(after) | indent(4) }}
      // **************** end custom code ****************
  } catch (...) {
      return handleAllExceptions({{ error[0] }}, {{ error[1] }});
  }

clib-implementation: |-
  {{ declaration }}
  {
      {{ body | indent(4) }}
  }

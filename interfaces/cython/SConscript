"""Cython-based Python Module"""
import re
from pathlib import Path
from buildutils import *

from string import Template

Import('env', 'build', 'install')

localenv = env.Clone()

dataFiles = localenv.RecursiveInstall("cantera/data", "#build/data")
build(dataFiles)

# Install Python samples
install(localenv.RecursiveInstall, "$inst_sampledir/python", "#samples/python")

setup_python_env(localenv)
# Python module shouldn't explicitly link to Python library (added in other cases to
# support Python-based extensions), except when using MinGW
if localenv["toolchain"] != "mingw":
    localenv["LIBS"] = [lib for lib in localenv["LIBS"] if not lib.startswith("python")]

setup_cfg = localenv.SubstFile("setup.cfg", "setup.cfg.in")
readme = localenv.Command("README.rst", "#README.rst", Copy("$TARGET", "$SOURCE"))
license = localenv.Command("LICENSE.txt", "#build/ext/LICENSE.txt",
                           Copy("$TARGET", "$SOURCE"))
localenv.Depends(license, localenv["license_target"])

directives = {"binding": True}
if env["coverage"]:
    directives["linetrace"] = True
    localenv.Append(CPPDEFINES={"CYTHON_TRACE": 1})

# Build the Python module
cython_obj = []
for pyxfile in multi_glob(localenv, "cantera", "pyx"):
    if pyxfile.name == "_utils.pyx":
        # Define GIT_COMMIT only in _utils.pyx to avoid unnecessary recompilations
        cython_env = localenv.Clone()
        cython_env.Append(CPPDEFINES={'GIT_COMMIT': '\\"{0}\\"'.format(env['git_commit'])})
    else:
        cython_env = localenv

    cython_output = f"cantera/{pyxfile.name.replace('.pyx', '.cpp')}"
    if pyxfile.name == "delegator.pyx":
        cython_output = [cython_output, "cantera/delegator.h"]

    cythonized = cython_env.Command(
         cython_output, pyxfile,
         f'''${{python_cmd}} -c "import Cython.Build; Cython.Build.cythonize(r'${{SOURCE}}', compiler_directives={directives!r})"'''
    )
    for pxd in multi_glob(cython_env, "cantera", "pxd"):
        cython_env.Depends(cythonized, pxd)

    obj = cython_env.SharedObject(
        f"#build/temp-py/{pyxfile.name.split('.')[0]}", cythonized[0])
    cython_obj.append(obj)

copy_header = localenv.Command('#src/extensions/delegator.h', '#build/python/cantera/delegator.h',
                          Copy('$TARGET', '$SOURCE'))
ext_manager = localenv.SharedObject("#src/extensions/PythonExtensionManager.cpp")

cython_obj.extend(ext_manager)
env.Depends(ext_manager, copy_header)

module_ext = localenv["py_module_ext"]
ext = localenv.LoadableModule(f"cantera/_cantera{module_ext}",
                              cython_obj, LIBPREFIX="", SHLIBSUFFIX=module_ext,
                              SHLIBPREFIX="", LIBSUFFIXES=[module_ext])

build_cmd = ("$python_cmd_esc -m pip wheel -v --no-build-isolation --no-deps "
             "--wheel-dir=build/python/dist build/python")
wheel_name = ("Cantera-${cantera_version}-cp${py_version_nodot}"
              "-cp${py_version_nodot}-${py_plat}.whl")
mod = build(localenv.Command(f"#build/python/dist/{wheel_name}", "setup.cfg",
                             build_cmd))
env['python_module'] = mod
env['python_extension'] = ext

localenv.Depends(mod, [ext, dataFiles, setup_cfg, readme, license,
                       "setup.py", "pyproject.toml",
                       "cantera/test/README.txt", "cantera/examples/README.txt"])

if env['OS'] == 'Windows':
    # On Windows, the cantera library directory is likely not to be on the path.
    # However, Windows does search the directory containing a library (i.e. the
    # Python extension module) for DLL dependencies.
    dll = [f for f in localenv['cantera_shlib'] if f.name.endswith('.dll')][0]
    copy_dll = localenv.Command(f'cantera/{dll.name}', dll, Copy("$TARGET", "$SOURCE"))
    localenv.Depends(ext, copy_dll)

    # If compiling with MinGW, there are some system libraries that also seem
    # to need to be installed alongside the Python extension -- elsewhere on the path
    # does not appear to work.
    if env['toolchain'] == 'mingw':
        mingw_dir = Path(which(env.subst('$CXX'))).parent
        prefixes = ['libgcc', 'libstdc++', 'libwinpthread']
        for lib in mingw_dir.glob('*.dll'):
            if any(lib.name.startswith(prefix) for prefix in prefixes):
                copy_lib = localenv.Command(f'cantera/{lib.name}', str(lib),
                                            Copy('$TARGET', '$SOURCE'))
                localenv.Depends(mod, copy_lib)

else:
    localenv.Depends(ext, localenv['cantera_shlib'])

for f in (multi_glob(localenv, 'cantera', 'py') +
          multi_glob(localenv, 'cantera/*', 'py')):
    localenv.Depends(mod, f)

UNITS = {
    "cp_mass": '"J/kg/K"', "cp_mole": '"J/kmol/K"', "cv_mass": '"J/kg/K"',
    "cv_mole": '"J/kmol/K"', "density_mass": '"kg/m**3"', "density_mole": '"kmol/m**3"',
    "enthalpy_mass": '"J/kg"', "enthalpy_mole": '"J/kmol"', "entropy_mass": '"J/kg/K"',
    "entropy_mole": '"J/kmol/K"', "gibbs_mass": '"J/kg"', "gibbs_mole": '"J/kmol"',
    "int_energy_mass": '"J/kg"', "int_energy_mole": '"J/kmol"',
    "volume_mass": '"m**3/kg"', "volume_mole": '"m**3/kmol"', "T": '"K"', "P": '"Pa"',
    "X": '"dimensionless"', "Y": '"dimensionless"', "Q": '"dimensionless"',
    "cp": '"J/K/" + self.basis_units', "cv": '"J/K/" + self.basis_units',
    "density": 'self.basis_units + "/m**3"', "h": '"J/" + self.basis_units',
    "s": '"J/K/" + self.basis_units', "g": '"J/" + self.basis_units',
    "u": '"J/" + self.basis_units', "v": '"m**3/" + self.basis_units',
    "H": '"J/" + self.basis_units', "V": '"m**3/" + self.basis_units',
    "S": '"J/K/" + self.basis_units', "D": 'self.basis_units + "/m**3"',
    "U": '"J/" + self.basis_units', "P_sat": '"Pa"', "T_sat": '"K"',
    "atomic_weight": '"kg/kmol"', "chemical_potentials": '"J/kmol"',
    "concentrations": '"kmol/m**3"', "critical_pressure": '"Pa"',
    "critical_temperature": '"K"', "critical_density": 'self.basis_units + "/m**3"',
    "electric_potential": '"V"', "electrochemical_potentials": '"J/kmol"',
    "isothermal_compressibility": '"1/Pa"', "max_temp": '"K"',
    "mean_molecular_weight": '"kg/kmol"', "min_temp": '"K"',
    "molecular_weights": '"kg/kmol"', "partial_molar_cp": '"J/kmol/K"',
    "partial_molar_enthalpies": '"J/kmol"', "partial_molar_entropies": '"J/kmol/K"',
    "partial_molar_int_energies": '"J/kmol"', "partial_molar_volumes": '"m**3/kmol"',
    "reference_pressure": '"Pa"', "thermal_expansion_coeff": '"1/K"'
}

SYMBOL = {
    "T": "T", "P": "P", "D": "density", "H": "h", "S": "s",
    "V": "v", "U": "u", "Q": "Q", "X": "X", "Y": "Y"
}

getter_properties = [
    "density_mass", "density_mole", "enthalpy_mass", "enthalpy_mole", "entropy_mass",
    "entropy_mole", "int_energy_mass", "int_energy_mole", "volume_mass", "volume_mole",
    "gibbs_mass", "gibbs_mole", "cp_mass", "cp_mole", "cv_mass", "cv_mole", "P",
    "P_sat", "T", "T_sat", "atomic_weight", "chemical_potentials", "concentrations",
    "critical_pressure", "critical_temperature", "critical_density",
    "electric_potential", "electrochemical_potentials", "isothermal_compressibility",
    "max_temp", "mean_molecular_weight", "min_temp", "molecular_weights",
    "partial_molar_cp", "partial_molar_enthalpies", "partial_molar_entropies",
    "partial_molar_int_energies", "partial_molar_volumes", "reference_pressure",
    "thermal_expansion_coeff", "cp", "cv", "density", "h", "s", "g", "u", "v",
]

getter_template = Template("""
    @property
    def ${name}(self):
        return Q_(self._phase.${name}, ${units})
""")

thermophase_getters = []
for name in getter_properties:
    thermophase_getters.append(getter_template.substitute(name=name, units=UNITS[name]))

setter_2_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1})

    @${name}.setter
    def ${name}(self, value):
        try:
            ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
            ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        except AttributeError as e:
            # The 'to' attribute missing means this isn't a pint Quantity
            if "'to'" in str(e):
                raise CanteraError(
                    f"Values ({value}) must be instances of pint.Quantity classes"
                ) from None
            else:
                raise
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude
""")

tp_setter_2_properties = ["TP", "DP", "HP", "SP", "SV", "TD", "UV"]
pf_setter_2_properties = ["PQ", "TQ", "PV", "SH", "ST", "TH", "TV", "UP", "VH"]

thermophase_2_setters = []
for name in tp_setter_2_properties:
    d = dict(name=name, n0=SYMBOL[name[0]], u0=UNITS[name[0]], n1=SYMBOL[name[1]],
             u1=UNITS[name[1]])
    thermophase_2_setters.append(setter_2_template.substitute(d))

purefluid_2_setters = []
for name in pf_setter_2_properties:
    d = dict(name=name, n0=SYMBOL[name[0]], u0=UNITS[name[0]], n1=SYMBOL[name[1]],
             u1=UNITS[name[1]])
    purefluid_2_setters.append(setter_2_template.substitute(d))

setter_3_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1}, ${n2} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1}), Q_(${n2}, ${u2})

    @${name}.setter
    def ${name}(self, value):
        try:
            ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
            ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        except AttributeError as e:
            # The 'to' attribute missing means this isn't a pint Quantity
            if "'to'" in str(e):
                raise CanteraError(
                    f"Values ({value}) must be instances of pint.Quantity classes"
                ) from None
            else:
                raise
        if value[2] is not None:
            try:
                ${n2} = value[2].to(${u2}).magnitude
            except AttributeError:
                ${n2} = value[2]
        else:
            ${n2} = self.${n2}.magnitude
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude, ${n2}
""")

tp_setter_3_properties = [
    "TPX", "TPY", "DPX", "DPY", "HPX", "HPY", "SPX", "SPY", "SVX", "SVY", "TDX", "TDY",
    "UVX", "UVY"
]

thermophase_3_setters = []
for name in tp_setter_3_properties:
    d = dict(name=name, n0=SYMBOL[name[0]], u0=UNITS[name[0]], n1=SYMBOL[name[1]],
             u1=UNITS[name[1]], n2=SYMBOL[name[2]], u2=UNITS[name[2]])
    thermophase_3_setters.append(setter_3_template.substitute(d))

getter_3_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1}, ${n2} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1}), Q_(${n2}, ${u2})
""")

pf_getter_3_properties = ["DPQ", "HPQ", "SPQ", "SVQ", "TDQ", "UVQ"]

purefluid_3_getters = []
for name in pf_getter_3_properties:
    d = dict(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]],
             n2=name[2], u2=UNITS[name[2]])
    purefluid_3_getters.append(getter_3_template.substitute(d))


def recursive_join(*args, joiner=""):
    result = ""
    for arg in args:
        result = result + joiner.join(arg)
    return result


thermophase_properties = recursive_join(thermophase_getters, thermophase_2_setters,
                                        thermophase_3_setters)
purefluid_properties = recursive_join(purefluid_2_setters, purefluid_3_getters)

common_properties = """
    def __getattr__(self, name):
        return getattr(self._phase, name)

    def __setattr__(self, name, value):
        if name in dir(self):
            object.__setattr__(self, name, value)
        else:
            setattr(self._phase, name, value)

    @property
    def basis_units(self):
        if self._phase.basis == "mass":
            return "kg"
        else:
            return "kmol"

    @property
    def X(self):
        X = self._phase.X
        return Q_(X, "dimensionless")

    @X.setter
    def X(self, value):
        if value is not None:
            try:
                X = value.to("dimensionless").magnitude
            except AttributeError:
                X = value
        else:
            X = self.X.magnitude
        self._phase.X = X

    @property
    def Y(self):
        Y = self._phase.Y
        return Q_(Y, "dimensionless")

    @Y.setter
    def Y(self, value):
        if value is not None:
            try:
                Y = value.to("dimensionless").magnitude
            except AttributeError:
                Y = value
        else:
            Y = self.Y.magnitude
        self._phase.Y = Y
"""

localenv["common_properties"] = common_properties.strip()
localenv["thermophase_properties"] = thermophase_properties.strip()
localenv["purefluid_properties"] = purefluid_properties.strip()
units = localenv.SubstFile(
    "cantera/with_units/solution.py",
    "cantera/with_units/solution.py.in",
)
localenv.Depends(mod, units)

# Determine installation path and install the Python module
install_cmd = ["$python_cmd_esc", "-m", "pip", "install"]
user_install = False
python_prefix = None
if localenv['python_prefix'] == 'USER':
    # Install to the OS-dependent user site-packages directory
    install_cmd.append("--user")
    user_install = True
elif localenv["python_prefix"]:
    # A specific location for the Cantera python module has been given
    install_cmd.append(f"--prefix={localenv.subst('$python_prefix')}")
    python_prefix = localenv.subst("$python_prefix")
elif not env["default_prefix"]:
    install_cmd.append(f"--prefix={env['prefix']}")
    python_prefix = env["prefix"]

# Check for existing Python module installation. Allow pip to remove an existing
# installation only if we're installing to the same location. Also disable
# uninstallation if we're installing to a staging directory.
if env["stage_dir"]:
    install_cmd.append("--ignore-installed")
else:
    info = get_command_output(localenv["python_cmd"], "-m", "pip", "show", "cantera",
                              ignore_errors=True)

    if user_install:
        test_prefix = Path(localenv["user_site_packages"]).parents[2]
    elif python_prefix is None:
        test_prefix = Path(localenv["site_packages"][0]).parents[2]
    else:
        test_prefix = Path(python_prefix)

    match = re.search(r"Location: (.*)\n", info, re.MULTILINE)
    existing_prefix = Path(match.group(1)).parents[2] if match else None
    if existing_prefix and existing_prefix != test_prefix:
        install_cmd.append("--ignore-installed")

if env["stage_dir"]:
    # Get the absolute path to the stage directory. If the stage directory is a relative
    # path, consider it to be relative to the root of the Cantera source directory.
    stage_dir = Path(env["stage_dir"])
    if not stage_dir.is_absolute():
        stage_dir = Path(Dir("#").abspath) / stage_dir

    install_cmd.append(f"--root={stage_dir.resolve()}")

install_cmd.extend(("--no-build-isolation", "--no-deps", "-v", "--force-reinstall",
                    "build/python"))
if localenv['PYTHON_INSTALLER'] == 'direct':
    mod_inst = install(localenv.Command, "dummy", mod, " ".join(install_cmd))
    env["install_python_action"] = mod_inst
    install_locs = get_pip_install_location(localenv["python_cmd"], user_install,
                                            python_prefix)
    env["python_module_loc"] = Path(install_locs["platlib"]).as_posix()
    env["ct_pyscriptdir"] = Path(install_locs["scripts"]).as_posix()
elif localenv['PYTHON_INSTALLER'] == 'debian':
    install(localenv.Command, 'dummy', mod,
            'cd build/python && '
            '$python_cmd_esc setup.py build --build-lib=. '
            'install --install-layout=deb --no-compile --root=${python_prefix}')
    env["python_module_loc"] = "<unspecified>"
